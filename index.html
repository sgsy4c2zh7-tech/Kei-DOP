<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>GNSS DOP Heatmap – CelesTrak + Repo TLE + satellite.js + TEC (Timeline 10-min)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 { margin: 0; letter-spacing: 0.03em; }
    h1 { font-size: 18px; }
    h2 { font-size: 15px; }
    h3 { font-size: 13px; }

    .page { display: flex; flex-direction: column; height: 100vh; }

    .toolbar {
      padding: 8px 12px;
      background: rgba(5, 8, 22, 0.96);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: grid;
      grid-template-columns: 2.8fr 3.2fr 2.4fr 3fr;
      grid-gap: 10px;
      align-items: flex-start;
      z-index: 1000;
    }

    .toolbar-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-start;
      font-size: 11px;
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      align-items: center;
    }

    .toolbar label {
      font-size: 11px;
      opacity: 0.9;
      white-space: nowrap;
    }

    .toolbar input[type="number"],
    .toolbar input[type="datetime-local"],
    .toolbar select,
    .toolbar textarea {
      font-size: 11px;
      padding: 2px 4px;
      background: #0b1020;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      color: #f5f5f5;
    }

    .toolbar textarea {
      width: 100%;
      resize: vertical;
      min-height: 40px;
      max-height: 140px;
    }

    .toolbar input[type="color"] {
      width: 24px;
      height: 18px;
      padding: 0;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: transparent;
    }

    .toolbar input[type="range"] { width: 220px; }

    .toolbar button {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #3b82f6, #22c55e);
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    .toolbar button:hover { opacity: 0.9; }
    .toolbar button.secondary { background: rgba(255,255,255,0.12); }

    .map-container { position: relative; flex: 1; min-height: 0; }
    #map { position: absolute; inset: 0; z-index: 200; }

    .leaflet-overlay-pane svg .dop-cell { stroke-width: 0; }

    .status-bar {
      position: absolute;
      left: 10px;
      bottom: 8px;
      z-index: 900;
      padding: 6px 10px;
      background: rgba(5, 8, 22, 0.85);
      border-radius: 999px;
      font-size: 11px;
      display: flex;
      gap: 10px;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.12);
    }

    .status-bar span.label { opacity: 0.75; }
    .status-bar span.value { font-variant-numeric: tabular-nums; }

    #statusText {
      position: absolute;
      right: 10px;
      bottom: 8px;
      z-index: 900;
      padding: 6px 10px;
      background: rgba(127, 29, 29, 0.9);
      color: #fecaca;
      font-size: 11px;
      border-radius: 8px;
      max-width: 520px;
      display: none;
      white-space: pre-wrap;
    }

    .colorbar-preview {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
      margin-top: 2px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .checkbox-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 11px;
    }
    .checkbox-row label span { margin-left: 2px; }

    .chip {
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      font-size: 10px;
      opacity: 0.8;
    }

    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>

  <script>
    (function () {
      const PASSWORD = "Haneishi";
      const input = prompt("パスワードを入力してください");
      if (input !== PASSWORD) {
        alert("パスワードが違います");
        document.body.innerHTML = "";
        throw new Error("Unauthorized");
      }
    })();
  </script>
</head>

<body>
  <div class="page">
    <div class="toolbar">
      <!-- GNSS & DOP -->
      <div class="toolbar-group">
        <div class="toolbar-row">
          <div class="checkbox-row">
            <label><input type="checkbox" class="sys-check" value="gps" checked><span>GPS</span></label>
            <label><input type="checkbox" class="sys-check" value="galileo" checked><span>Galileo</span></label>
            <label><input type="checkbox" class="sys-check" value="glonass" checked><span>GLONASS</span></label>
            <label><input type="checkbox" class="sys-check" value="beidou" checked><span>BeiDou</span></label>
            <label><input type="checkbox" class="sys-check" value="qzss" checked><span>QZSS</span></label>
          </div>
        </div>

        <div class="toolbar-row">
          <label>
            DOP:
            <select id="dopType">
              <option value="GDOP">GDOP</option>
              <option value="PDOP">PDOP</option>
              <option value="HDOP">HDOP</option>
              <option value="VDOP">VDOP</option>
            </select>
          </label>
          <label>
            仰角マスク(°):
            <input id="elevMask" type="number" value="15" min="0" max="45" step="1" />
          </label>
          <label>
            基準高度(km):
            <input id="obsHeightKm" type="number" value="0" step="0.1" />
          </label>
        </div>

        <!-- ★追加：TLEソース切替 -->
        <div class="toolbar-row">
          <label>
            TLE source:
            <select id="tleSource">
              <option value="celestrak">CelesTrak (live)</option>
              <option value="repo">Repo library (daily)</option>
              <option value="localcache">Browser cache</option>
              <option value="manual">Manual paste</option>
            </select>
          </label>
        </div>

        <!-- ★追加：manual貼り付け -->
        <div class="toolbar-row" style="width:100%;">
          <textarea id="manualTleInput" placeholder="Manual TLE (name + 2 lines) を貼り付け。source=Manualで使用"></textarea>
        </div>

        <div class="toolbar-row">
          <button id="reloadTle">TLE更新（保存）</button>
          <button id="clearTleCache" class="secondary">TLE履歴クリア</button>
        </div>

        <div class="toolbar-row" style="font-size:10px;opacity:0.75;max-width:320px;">
          ※ Repo library は data/gnss/* の日次アーカイブを参照します（GitHub Actionsで毎日更新）。
        </div>
      </div>

      <!-- 時間範囲 + タイムスライダー（10分刻み） -->
      <div class="toolbar-group">
        <div class="toolbar-row" style="justify-content:space-between;width:100%;">
          <span class="chip">Timeline (10-min)</span>
        </div>

        <div class="toolbar-row">
          <label>開始:<input id="startTime" type="datetime-local" /></label>
          <label>終了:<input id="endTime" type="datetime-local" /></label>
          <button id="applyRange" class="secondary">範囲反映</button>
        </div>

        <div class="toolbar-row">
          <label>時刻:<input id="timeIndex" type="range" min="0" max="0" step="1" value="0" /></label>
        </div>

        <div class="toolbar-row">
          <span class="mono" id="timeLabel">UTC: -</span>
          <span style="opacity:0.7;">/</span>
          <span class="mono" id="stepLabel">step: -</span>
        </div>

        <div class="toolbar-row">
          <button id="playBtn">▶ Play</button>
          <button id="pauseBtn" class="secondary">⏸ Pause</button>
          <button id="toStartBtn" class="secondary">⏮</button>
          <button id="toEndBtn" class="secondary">⏭</button>

          <label title="再生間隔（ms）">
            speed:
            <input id="playIntervalMs" type="number" value="120" min="20" step="10" style="width:70px;" />
          </label>
        </div>

        <div class="toolbar-row">
          <label>
            フォーカス:
            <select id="focusRegion">
              <option value="world">World</option>
              <option value="japan">（Japan）</option>
              <option value="us">USA</option>
              <option value="europe">Europe</option>
              <option value="australia">Australia</option>
              <option value="southamerica">South America</option>
              <option value="africa">Africa</option>
            </select>
          </label>
        </div>
      </div>

      <!-- カラーバー & 透明度 -->
      <div class="toolbar-group">
        <div class="toolbar-row">
          <label>DOP min:<input id="dopMin" type="number" value="0.5" step="0.1" /></label>
          <label>DOP max:<input id="dopMax" type="number" value="10" step="0.5" /></label>
        </div>
        <div class="toolbar-row">
          <label>色(低):<input id="colorLow" type="color" value="#22c55e" /></label>
          <label>色(中):<input id="colorMid" type="color" value="#eab308" /></label>
          <label>色(高):<input id="colorHigh" type="color" value="#ef4444" /></label>
        </div>
        <div class="colorbar-preview" id="colorbarPreview"></div>
        <div class="toolbar-row">
          <label>ヒートマップ透明度:<input id="alphaSlider" type="range" min="0.1" max="1" step="0.05" value="0.7" /></label>
          <span id="alphaLabel" style="font-size:11px;">α = 0.70</span>
        </div>
        <div class="toolbar-row">
          <button id="recalcBtn">再計算</button>
          <label title="ドラッグ中は軽量解像度で描画して追従します">
            drag軽量:
            <input type="checkbox" id="dragLite" checked />
          </label>
        </div>
      </div>

      <!-- TEC -->
      <div class="toolbar-group">
        <div class="toolbar-row" style="justify-content:space-between;width:100%;">
          <span class="chip">TECU予報インプット → DOP補正</span>
        </div>
        <div class="toolbar-row" style="width:100%;">
          <textarea id="tecInput" placeholder="例: lat,lon,tec&#10;35,140,40&#10;40,140,60"></textarea>
        </div>
        <div class="toolbar-row">
          <button id="loadTecBtn">TEC読み込み</button>
          <label style="display:flex;align-items:center;gap:4px;">
            <input type="checkbox" id="useTecCheckbox" />
            <span>TEC反映</span>
          </label>
        </div>
        <div class="toolbar-row">
          <label>TEC基準(TECU):<input id="tecRef" type="number" value="20" step="1" style="width:60px;" /></label>
          <label title="(TEC-TEC基準)/TEC基準 × β">β(感度):<input id="tecBeta" type="number" value="0.5" step="0.1" style="width:60px;" /></label>
        </div>
        <div class="toolbar-row" style="font-size:10px;opacity:0.8;max-width:260px;">
          DOP補正式: DOP_eff = DOP_geom × (1 + β × (TEC − TEC基準) / TEC基準)
        </div>
      </div>
    </div>

    <div class="map-container">
      <div id="map"></div>

      <div class="status-bar">
        <span class="label">TLE採用:</span>
        <span class="value mono" id="epochLabel">–</span>
        <span class="label">可視衛星数(東京):</span>
        <span class="value mono" id="visibleTokyoLabel">–</span>
        <span class="label">DOP(東京):</span>
        <span class="value mono" id="dopTokyoLabel">–</span>
      </div>

      <div id="statusText"></div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin="">
  </script>

  <!-- satellite.js (SGP4) -->
  <script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>

  <script>
    // ====== GNSS設定 ======
    const systemsConfig = {
      gps:     { label: "GPS",     group: "gps-ops", repoIndex: "data/gnss/gps/index.json" },
      galileo: { label: "Galileo", group: "galileo", repoIndex: "data/gnss/galileo/index.json" },
      glonass: { label: "GLONASS", group: "glonass", repoIndex: "data/gnss/glonass/index.json" },
      beidou:  { label: "BeiDou",  group: "beidou",  repoIndex: "data/gnss/beidou/index.json" },
      qzss:    { label: "QZSS",    group: "qzss",    repoIndex: "data/gnss/qzss/index.json" }
    };

    // ====== グリッド ======
    const LAT_STEP = 10, LON_STEP = 10;
    const LAT_STEP_LITE = 20, LON_STEP_LITE = 20;

    // ====== TLE履歴（localStorage） ======
    const TLE_CACHE_KEY = "gnss_tle_snapshots_v1";
    const TLE_CACHE_KEEP_HOURS = 72;
    const TLE_MAX_SNAPSHOTS_PER_SYS = 60;

    function loadTleSnapshots() {
      try {
        const raw = localStorage.getItem(TLE_CACHE_KEY);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        return obj && typeof obj === "object" ? obj : {};
      } catch { return {}; }
    }
    function saveTleSnapshots(obj) {
      try { localStorage.setItem(TLE_CACHE_KEY, JSON.stringify(obj)); }
      catch (e) { console.warn("TLE snapshot save failed", e); }
    }
    function pruneSnapshots(snapshots) {
      const nowMs = Date.now();
      const keepMs = TLE_CACHE_KEEP_HOURS * 3600 * 1000;
      for (const sys of Object.keys(snapshots)) {
        snapshots[sys] = (snapshots[sys] || [])
          .filter(s => (nowMs - s.fetchedAtMs) <= keepMs)
          .sort((a,b) => a.fetchedAtMs - b.fetchedAtMs);
        if (snapshots[sys].length > TLE_MAX_SNAPSHOTS_PER_SYS) {
          snapshots[sys] = snapshots[sys].slice(-TLE_MAX_SNAPSHOTS_PER_SYS);
        }
      }
      return snapshots;
    }
    function addSnapshot(sys, tleText) {
      const snapshots = loadTleSnapshots();
      const arr = snapshots[sys] || [];
      const fetchedAtMs = Date.now();
      const last = arr.length ? arr[arr.length - 1] : null;
      if (last && last.tleText === tleText) return;
      arr.push({ fetchedAtMs, tleText });
      snapshots[sys] = arr;
      saveTleSnapshots(pruneSnapshots(snapshots));
    }
    function pickSnapshotForTime(sys, targetMs) {
      const snapshots = pruneSnapshots(loadTleSnapshots());
      const arr = snapshots[sys] || [];
      if (!arr.length) return null;
      let best = arr[0];
      let bestAbs = Math.abs(arr[0].fetchedAtMs - targetMs);
      for (const s of arr) {
        const d = Math.abs(s.fetchedAtMs - targetMs);
        if (d < bestAbs) { bestAbs = d; best = s; }
      }
      return best;
    }

    // ====== Repo TLE: index.json を使って「近い日」を選ぶ ======
    const repoIndexCache = new Map(); // sys -> index.json
    async function loadRepoIndex(sys) {
      if (repoIndexCache.has(sys)) return repoIndexCache.get(sys);
      const url = systemsConfig[sys]?.repoIndex;
      if (!url) throw new Error("repoIndex not defined for " + sys);
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("repo index fetch failed: " + res.status);
      const j = await res.json();
      repoIndexCache.set(sys, j);
      return j;
    }

    function toUtcDateStr(d) {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,"0");
      const da = String(d.getUTCDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }

    function pickNearestArchive(indexJson, targetDateStr) {
      const arr = indexJson.archives || [];
      if (!arr.length) return null;

      // 日付差を最小にする
      const target = new Date(targetDateStr + "T00:00:00Z").getTime();
      let best = arr[0];
      let bestAbs = Infinity;
      for (const it of arr) {
        const t = new Date(it.date + "T00:00:00Z").getTime();
        const d = Math.abs(t - target);
        if (d < bestAbs) { bestAbs = d; best = it; }
      }
      return best;
    }

    async function fetchRepoTleForTime(sys, time) {
      const idx = await loadRepoIndex(sys);
      const day = toUtcDateStr(time);
      const best = pickNearestArchive(idx, day);
      if (!best) {
        // fallback to latest
        const res0 = await fetch(idx.latest, { cache: "no-store" });
        if (!res0.ok) throw new Error("repo latest fetch failed");
        return { tleText: await res0.text(), label: `${systemsConfig[sys].label}@REPO(LATEST)` };
      }
      const res = await fetch(best.path, { cache: "no-store" });
      if (!res.ok) throw new Error("repo archive fetch failed: " + best.path);
      return { tleText: await res.text(), label: `${systemsConfig[sys].label}@REPO(${best.date})` };
    }

    // ====== グローバル状態 ======
    let allSatellites = []; // [{name, system, satrec}]
    let dopLayer = null;
    let currentAlpha = 0.7;
    let tecGrid = [];
    let tecLoaded = false;
    let playTimer = null;

    // UI
    const dopTypeSel   = document.getElementById("dopType");
    const elevMaskEl   = document.getElementById("elevMask");
    const obsHeightEl  = document.getElementById("obsHeightKm");
    const startTimeEl  = document.getElementById("startTime");
    const endTimeEl    = document.getElementById("endTime");
    const applyRangeBtn= document.getElementById("applyRange");
    const timeIndexEl  = document.getElementById("timeIndex");
    const timeLabelEl  = document.getElementById("timeLabel");
    const stepLabelEl  = document.getElementById("stepLabel");
    const playBtn      = document.getElementById("playBtn");
    const pauseBtn     = document.getElementById("pauseBtn");
    const toStartBtn   = document.getElementById("toStartBtn");
    const toEndBtn     = document.getElementById("toEndBtn");
    const playIntervalMsEl = document.getElementById("playIntervalMs");
    const focusRegionEl   = document.getElementById("focusRegion");
    const dopMinEl    = document.getElementById("dopMin");
    const dopMaxEl    = document.getElementById("dopMax");
    const colorLowEl  = document.getElementById("colorLow");
    const colorMidEl  = document.getElementById("colorMid");
    const colorHighEl = document.getElementById("colorHigh");
    const colorbarPreview = document.getElementById("colorbarPreview");
    const alphaSlider = document.getElementById("alphaSlider");
    const alphaLabel  = document.getElementById("alphaLabel");
    const reloadTleBtn= document.getElementById("reloadTle");
    const clearTleCacheBtn = document.getElementById("clearTleCache");
    const recalcBtn   = document.getElementById("recalcBtn");
    const dragLiteEl  = document.getElementById("dragLite");
    const epochLabel  = document.getElementById("epochLabel");
    const visibleTokyoLabel = document.getElementById("visibleTokyoLabel");
    const dopTokyoLabel     = document.getElementById("dopTokyoLabel");
    const statusText  = document.getElementById("statusText");
    const sysChecks   = document.querySelectorAll(".sys-check");
    const tecInputEl  = document.getElementById("tecInput");
    const loadTecBtn  = document.getElementById("loadTecBtn");
    const useTecCheckbox = document.getElementById("useTecCheckbox");
    const tecRefEl    = document.getElementById("tecRef");
    const tecBetaEl   = document.getElementById("tecBeta");

    // ★追加
    const tleSourceEl = document.getElementById("tleSource");
    const manualTleInputEl = document.getElementById("manualTleInput");

    // ====== Map ======
    const map = L.map("map", {
      worldCopyJump: true,
      center: [35, 140],
      zoom: 3
    });

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 8,
      minZoom: 2,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    dopLayer = L.layerGroup().addTo(map);

    function setStatus(msg, isError = false) {
      if (!msg) {
        statusText.style.display = "none";
        statusText.textContent = "";
        return;
      }
      statusText.style.display = "block";
      statusText.textContent = msg;
      statusText.style.background = isError ? "rgba(127,29,29,0.9)" : "rgba(15,23,42,0.9)";
      statusText.style.color = isError ? "#fecaca" : "#e5e7eb";
    }

    // ====== 色 ======
    function hexToRgb(hex) {
      const m = hex.replace("#", "");
      const bigint = parseInt(m, 16);
      return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 };
    }
    function interpColor(c1, c2, t) {
      return {
        r: Math.round(c1.r + (c2.r - c1.r) * t),
        g: Math.round(c1.g + (c2.g - c1.g) * t),
        b: Math.round(c1.b + (c2.b - c1.b) * t)
      };
    }
    function colorForDop(value, minV, maxV, lowHex, midHex, highHex) {
      if (value == null || isNaN(value)) return "rgba(0,0,0,0)";
      if (value <= minV) value = minV;
      if (value >= maxV) value = maxV;
      const t = (value - minV) / (maxV - minV + 1e-9);
      const low = hexToRgb(lowHex);
      const mid = hexToRgb(midHex);
      const high = hexToRgb(highHex);

      let c;
      if (t < 0.5) c = interpColor(low, mid, t * 2);
      else c = interpColor(mid, high, (t - 0.5) * 2);

      return `rgba(${c.r},${c.g},${c.b},${currentAlpha})`;
    }
    function updateColorbarPreview() {
      colorbarPreview.style.background = `linear-gradient(90deg, ${colorLowEl.value}, ${colorMidEl.value}, ${colorHighEl.value})`;
    }
    updateColorbarPreview();
    colorLowEl.addEventListener("input", updateColorbarPreview);
    colorMidEl.addEventListener("input", updateColorbarPreview);
    colorHighEl.addEventListener("input", updateColorbarPreview);

    function updateAlpha() {
      currentAlpha = parseFloat(alphaSlider.value);
      alphaLabel.textContent = `α = ${currentAlpha.toFixed(2)}`;
      dopLayer.eachLayer(layer => { if (layer.setStyle) layer.setStyle({ fillOpacity: currentAlpha }); });
    }
    updateAlpha();
    alphaSlider.addEventListener("input", updateAlpha);

    // ====== フォーカス ======
    focusRegionEl.addEventListener("change", () => {
      const v = focusRegionEl.value;
      switch (v) {
        case "world":        map.setView([20, 0], 2);   break;
        case "japan":        map.setView([36, 138], 5); break;
        case "us":           map.setView([39, -100], 4);break;
        case "europe":       map.setView([50, 10], 4);  break;
        case "australia":    map.setView([-25, 135], 4);break;
        case "southamerica": map.setView([-15, -60], 4);break;
        case "africa":       map.setView([0, 20], 4);   break;
      }
    });

    // ====== 時間ユーティリティ ======
    const TEN_MIN_MS = 10 * 60 * 1000;
    function pad2(n) { return String(n).padStart(2, "0"); }
    function toLocalInputValue(dt) {
      return `${dt.getFullYear()}-${pad2(dt.getMonth()+1)}-${pad2(dt.getDate())}T${pad2(dt.getHours())}:${pad2(dt.getMinutes())}`;
    }
    function parseLocalInputValue(v) {
      const dt = new Date(v);
      return isNaN(dt.getTime()) ? null : dt;
    }
    function formatUtc(dt) {
      return `${dt.getUTCFullYear()}-${pad2(dt.getUTCMonth()+1)}-${pad2(dt.getUTCDate())} ${pad2(dt.getUTCHours())}:${pad2(dt.getUTCMinutes())} UTC`;
    }

    // ====== タイムライン状態 ======
    let rangeStart = null;
    let rangeEnd   = null;

    function clampRangeToNowPlusMinus3days() {
      const now = new Date();
      const min = new Date(now.getTime() - 3*24*3600*1000);
      const max = new Date(now.getTime() + 3*24*3600*1000);
      startTimeEl.min = toLocalInputValue(min);
      startTimeEl.max = toLocalInputValue(max);
      endTimeEl.min   = toLocalInputValue(min);
      endTimeEl.max   = toLocalInputValue(max);
      const defS = new Date(now.getTime() - 6*3600*1000);
      const defE = new Date(now.getTime() + 6*3600*1000);
      startTimeEl.value = toLocalInputValue(defS);
      endTimeEl.value   = toLocalInputValue(defE);
    }

    function applyRangeFromInputs() {
      const s = parseLocalInputValue(startTimeEl.value);
      const e = parseLocalInputValue(endTimeEl.value);
      if (!s || !e) { setStatus("開始/終了の日時が不正です。", true); return false; }
      if (e.getTime() <= s.getTime()) { setStatus("終了は開始より後にしてください。", true); return false; }
      rangeStart = s;
      rangeEnd = e;
      const steps = Math.floor((rangeEnd.getTime() - rangeStart.getTime()) / TEN_MIN_MS) + 1;
      timeIndexEl.min = 0;
      timeIndexEl.max = Math.max(0, steps - 1);
      timeIndexEl.step = 1;
      const cur = parseInt(timeIndexEl.value || "0", 10);
      if (cur > (steps - 1)) timeIndexEl.value = steps - 1;
      updateTimeLabels();
      setStatus(`範囲反映: ${formatUtc(rangeStart)} 〜 ${formatUtc(rangeEnd)}（${steps} frames）`, false);
      return true;
    }

    function getSelectedTime() {
      const idx = parseInt(timeIndexEl.value || "0", 10);
      return new Date(rangeStart.getTime() + idx * TEN_MIN_MS);
    }

    function updateTimeLabels() {
      if (!rangeStart || !rangeEnd) { timeLabelEl.textContent = "UTC: -"; stepLabelEl.textContent = "step: -"; return; }
      const idx = parseInt(timeIndexEl.value || "0", 10);
      const steps = parseInt(timeIndexEl.max || "0", 10) + 1;
      const t = getSelectedTime();
      timeLabelEl.textContent = `UTC: ${formatUtc(t)}`;
      stepLabelEl.textContent = `step: ${idx+1}/${steps} (10min)`;
    }

    // ====== TLE取得（CelesTrak） ======
    async function fetchTleGroup(groupName) {
      const url = `https://celestrak.org/NORAD/elements/gp.php?GROUP=${encodeURIComponent(groupName)}&FORMAT=tle`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`TLE取得失敗: ${groupName} (${res.status})`);
      return await res.text();
    }

    function parseTleText(tleText, systemKey) {
      const lines = tleText.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      const sats = [];
      let tmpName = null;
      let satIndex = 0;

      for (let i = 0; i < lines.length; ) {
        const line = lines[i];

        if (!line.startsWith("1 ") && !line.startsWith("2 ")) {
          tmpName = line;
          i++;
          continue;
        }

        if (line.startsWith("1 ") && (i + 1) < lines.length && lines[i + 1].startsWith("2 ")) {
          const l1 = lines[i];
          const l2 = lines[i + 1];
          const name = tmpName || `${systemKey.toUpperCase()}-${++satIndex}`;
          try {
            const satrec = satellite.twoline2satrec(l1, l2);
            sats.push({ name, system: systemKey, satrec });
          } catch (e) {
            console.warn("TLE parse error", name, e);
          }
          tmpName = null;
          i += 2;
          continue;
        }
        i++;
      }
      return sats;
    }

    function getSelectedSystems() {
      const selected = [];
      sysChecks.forEach(ch => { if (ch.checked) selected.push(ch.value); });
      return selected;
    }

    // ★統合：ソース別にTLEテキストを取る
    async function getTleTextForSystemAtTime(sys, targetTime) {
      const src = tleSourceEl.value;
      const cfg = systemsConfig[sys];
      if (!cfg) throw new Error("unknown sys " + sys);

      if (src === "manual") {
        const txt = (manualTleInputEl.value || "").trim();
        if (!txt) throw new Error("Manual TLE is empty");
        return { tleText: txt, label: `${cfg.label}@MANUAL` };
      }

      if (src === "repo") {
        return await fetchRepoTleForTime(sys, targetTime);
      }

      if (src === "localcache") {
        const snap = pickSnapshotForTime(sys, targetTime.getTime());
        if (snap && snap.tleText) {
          return { tleText: snap.tleText, label: `${cfg.label}@CACHE` };
        }
        // fallback
        const live = await fetchTleGroup(cfg.group);
        return { tleText: live, label: `${cfg.label}@LIVE(FB)` };
      }

      // default: celestrak live
      const live = await fetchTleGroup(cfg.group);
      return { tleText: live, label: `${cfg.label}@LIVE` };
    }

    // 選択時刻に応じて衛星セット再構築
    async function buildSatellitesForTime(targetTime) {
      const selected = getSelectedSystems();
      if (!selected.length) {
        setStatus("少なくとも1つのGNSSシステムを選択してください。", true);
        return false;
      }

      allSatellites = [];
      const pickedInfo = [];

      for (const sys of selected) {
        const { tleText, label } = await getTleTextForSystemAtTime(sys, targetTime);
        pickedInfo.push(label);
        const sats = parseTleText(tleText, sys);
        allSatellites.push(...sats);
      }

      epochLabel.textContent = pickedInfo.join(" / ");
      return allSatellites.length > 0;
    }

    // 手動TLE更新（保存する）= CelesTrak live を localStorage に保存（今まで通り）
    async function refreshAndStoreTles() {
      setStatus("TLE取得中（保存）...", false);

      const selected = getSelectedSystems();
      if (!selected.length) {
        setStatus("少なくとも1つのGNSSシステムを選択してください。", true);
        return;
      }

      try {
        for (const sys of selected) {
          const cfg = systemsConfig[sys];
          const txt = await fetchTleGroup(cfg.group);
          addSnapshot(sys, txt);
        }
        setStatus("TLE更新＆保存完了（Browser cache）。", false);
      } catch (e) {
        console.error(e);
        setStatus("TLE更新でエラー: " + e.message, true);
      }
    }

    reloadTleBtn.addEventListener("click", async () => {
      await refreshAndStoreTles();
      if (rangeStart) {
        const t = getSelectedTime();
        await buildSatellitesForTime(t);
        recalcDopHeatmap({ lite: false });
      }
    });

    clearTleCacheBtn.addEventListener("click", () => {
      localStorage.removeItem(TLE_CACHE_KEY);
      setStatus("TLE履歴（localStorage）を削除しました。", false);
    });

    // ====== 行列DOP ======
    function invert4(M) {
      const A = [
        [...M[0], 1,0,0,0],
        [...M[1], 0,1,0,0],
        [...M[2], 0,0,1,0],
        [...M[3], 0,0,0,1]
      ];
      const N = 4;
      for (let i = 0; i < N; i++) {
        let maxRow = i, maxVal = Math.abs(A[i][i]);
        for (let r = i+1; r < N; r++) {
          const v = Math.abs(A[r][i]);
          if (v > maxVal) { maxVal = v; maxRow = r; }
        }
        if (maxVal < 1e-12) return null;
        if (maxRow !== i) { const tmp = A[i]; A[i] = A[maxRow]; A[maxRow] = tmp; }

        const pivot = A[i][i];
        for (let c = 0; c < 8; c++) A[i][c] /= pivot;

        for (let r = 0; r < N; r++) {
          if (r === i) continue;
          const factor = A[r][i];
          for (let c = 0; c < 8; c++) A[r][c] -= factor * A[i][c];
        }
      }
      return [
        [A[0][4],A[0][5],A[0][6],A[0][7]],
        [A[1][4],A[1][5],A[1][6],A[1][7]],
        [A[2][4],A[2][5],A[2][6],A[2][7]],
        [A[3][4],A[3][5],A[3][6],A[3][7]]
      ];
    }

    function computeDopsFromMatrix(G) {
      const n = G.length;
      if (n < 4) return { GDOP: null, PDOP: null, HDOP: null, VDOP: null };
      const GTG = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
      for (let i = 0; i < n; i++) {
        const row = G[i];
        for (let r = 0; r < 4; r++) for (let c = 0; c < 4; c++) GTG[r][c] += row[r] * row[c];
      }
      const Q = invert4(GTG);
      if (!Q) return { GDOP: null, PDOP: null, HDOP: null, VDOP: null };
      const qxx = Q[0][0], qyy = Q[1][1], qzz = Q[2][2], qtt = Q[3][3];
      return {
        GDOP: Math.sqrt(Math.max(qxx + qyy + qzz + qtt, 0)),
        PDOP: Math.sqrt(Math.max(qxx + qyy + qzz, 0)),
        HDOP: Math.sqrt(Math.max(qxx + qyy, 0)),
        VDOP: Math.sqrt(Math.max(qzz, 0))
      };
    }

    // ====== TEC ======
    function parseTecCsv(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      if (!lines.length) return [];
      const result = [];
      let startIdx = 0;
      if (/[a-zA-Z]/.test(lines[0])) startIdx = 1;

      for (let i = startIdx; i < lines.length; i++) {
        const cols = lines[i].split(/[,\s]+/).map(c => c.trim());
        if (cols.length < 3) continue;
        const lat = parseFloat(cols[0]);
        const lon = parseFloat(cols[1]);
        const tec = parseFloat(cols[2]);
        if (!isFinite(lat) || !isFinite(lon) || !isFinite(tec)) continue;
        result.push({ lat, lon, tec });
      }
      return result;
    }

    function getTecAt(latDeg, lonDeg) {
      if (!tecLoaded || !tecGrid.length) return null;
      let best = null, bestDist2 = Infinity;
      for (const p of tecGrid) {
        const dLat = latDeg - p.lat;
        let dLon = lonDeg - p.lon;
        if (dLon > 180) dLon -= 360;
        if (dLon < -180) dLon += 360;
        const dist2 = dLat*dLat + dLon*dLon;
        if (dist2 < bestDist2) { bestDist2 = dist2; best = p; }
      }
      if (bestDist2 > 30*30) return null;
      return best.tec;
    }

    function applyTecToDop(dopVal, latDeg, lonDeg) {
      if (!useTecCheckbox.checked) return dopVal;
      if (!tecLoaded) return dopVal;
      if (dopVal == null || !isFinite(dopVal)) return dopVal;

      const tec = getTecAt(latDeg, lonDeg);
      if (tec == null || !isFinite(tec)) return dopVal;

      const tecRef = parseFloat(tecRefEl.value) || 20;
      const beta   = parseFloat(tecBetaEl.value) || 0.5;
      const ratio = (tec - tecRef) / tecRef;
      const factor = 1 + beta * ratio;
      const limitedFactor = Math.max(0.3, Math.min(factor, 5.0));
      return dopVal * limitedFactor;
    }

    loadTecBtn.addEventListener("click", () => {
      const txt = tecInputEl.value.trim();
      if (!txt) { setStatus("TEC入力欄が空です。lat,lon,tec の形式で貼り付けてください。", true); return; }
      const parsed = parseTecCsv(txt);
      if (!parsed.length) { setStatus("TECデータのパースに失敗しました。形式を確認してください。", true); return; }
      tecGrid = parsed;
      tecLoaded = true;
      setStatus(`TECデータ読込（ポイント数: ${tecGrid.length}）。「TEC反映」でDOP補正。`, false);
    });

    // ====== DOP計算（1点） ======
    function computeDopAtLocation(latDeg, lonDeg, heightKm, time, elevMaskDeg) {
      if (!allSatellites.length) return { dops: {GDOP:null,PDOP:null,HDOP:null,VDOP:null}, visibleCount: 0 };
      const gmst = satellite.gstime(time);
      const observerGd = {
        latitude:  satellite.degreesToRadians(latDeg),
        longitude: satellite.degreesToRadians(lonDeg),
        height:    heightKm
      };

      const G = [];
      let visibleCount = 0;

      for (const sat of allSatellites) {
        const prop = satellite.propagate(sat.satrec, time);
        if (!prop.position) continue;

        const positionEcf = satellite.eciToEcf(prop.position, gmst);
        const look = satellite.ecfToLookAngles(observerGd, positionEcf);
        const elevDeg = satellite.radiansToDegrees(look.elevation);
        if (elevDeg < elevMaskDeg) continue;

        visibleCount++;
        const az = look.azimuth;
        const el = look.elevation;
        const cosEl = Math.cos(el);
        const sinEl = Math.sin(el);
        const eComp = cosEl * Math.sin(az);
        const nComp = cosEl * Math.cos(az);
        const uComp = sinEl;
        G.push([eComp, nComp, uComp, 1.0]);
      }

      const dopsGeom = computeDopsFromMatrix(G);
      return { dops: dopsGeom, visibleCount };
    }

    // ====== ヒートマップ計算 ======
    function recalcDopHeatmap({ lite = false } = {}) {
      if (!allSatellites.length) { setStatus("TLEが未ロードです。", true); return; }
      if (!rangeStart || !rangeEnd) { setStatus("時間範囲が未設定です。", true); return; }

      const dopType = dopTypeSel.value;
      const elevMask = parseFloat(elevMaskEl.value) || 15;
      const obsHeightKm = parseFloat(obsHeightEl.value) || 0;
      const dopMin = parseFloat(dopMinEl.value) || 0.5;
      const dopMax = parseFloat(dopMaxEl.value) || 10;
      const lowC  = colorLowEl.value;
      const midC  = colorMidEl.value;
      const highC = colorHighEl.value;

      const time = getSelectedTime();
      updateTimeLabels();

      const latStep = lite ? LAT_STEP_LITE : LAT_STEP;
      const lonStep = lite ? LON_STEP_LITE : LON_STEP;

      setStatus(`DOP計算中... (${lite ? "drag-lite" : "full"})`, false);
      dopLayer.clearLayers();

      const tokyoRaw = computeDopAtLocation(35.68, 139.76, obsHeightKm, time, elevMask);
      visibleTokyoLabel.textContent = String(tokyoRaw.visibleCount);

      const d = tokyoRaw.dops;
      if (d.GDOP == null) dopTokyoLabel.textContent = "–";
      else {
        const gEff = applyTecToDop(d.GDOP, 35.68, 139.76);
        const pEff = applyTecToDop(d.PDOP, 35.68, 139.76);
        const hEff = applyTecToDop(d.HDOP, 35.68, 139.76);
        const vEff = applyTecToDop(d.VDOP, 35.68, 139.76);
        dopTokyoLabel.textContent = `G:${gEff.toFixed(1)} P:${pEff.toFixed(1)} H:${hEff.toFixed(1)} V:${vEff.toFixed(1)}`;
      }

      for (let lat = -80; lat <= 80; lat += latStep) {
        for (let lon = -180; lon < 180; lon += lonStep) {
          const centerLat = lat + latStep / 2;
          const centerLon = lon + lonStep / 2;

          const { dops } = computeDopAtLocation(centerLat, centerLon, obsHeightKm, time, elevMask);
          let val = dops[dopType] || null;
          if (val == null || !isFinite(val)) continue;

          val = applyTecToDop(val, centerLat, centerLon);
          const color = colorForDop(val, dopMin, dopMax, lowC, midC, highC);

          const bounds = [[lat, lon],[lat + latStep, lon + lonStep]];
          dopLayer.addLayer(L.rectangle(bounds, {
            stroke: false,
            fillColor: color,
            fillOpacity: currentAlpha,
            interactive: false,
            className: "dop-cell"
          }));
        }
      }

      setStatus(`DOP完了: ${formatUtc(time)} / 仰角≥${elevMask.toFixed(0)}° / TLE:${tleSourceEl.value} / TEC:${useTecCheckbox.checked ? "ON" : "OFF"} / ${lite ? "LITE" : "FULL"}`, false);
    }

    recalcBtn.addEventListener("click", () => recalcDopHeatmap({ lite:false }));

    // ====== スライダー追従 ======
    let rafPending = false;
    function scheduleRecalcOnScrub(isFinal) {
      const wantLite = !isFinal && dragLiteEl.checked;
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(async () => {
        rafPending = false;
        const t = getSelectedTime();
        await buildSatellitesForTime(t);
        recalcDopHeatmap({ lite: wantLite });
      });
    }

    timeIndexEl.addEventListener("input", () => {
      updateTimeLabels();
      scheduleRecalcOnScrub(false);
    });
    timeIndexEl.addEventListener("change", () => {
      updateTimeLabels();
      scheduleRecalcOnScrub(true);
    });

    // ====== 再生 ======
    function stopPlay() { if (playTimer) clearInterval(playTimer); playTimer = null; }
    playBtn.addEventListener("click", () => {
      if (!rangeStart) return;
      stopPlay();
      const interval = Math.max(20, parseInt(playIntervalMsEl.value || "120", 10));
      playTimer = setInterval(() => {
        const cur = parseInt(timeIndexEl.value || "0", 10);
        const max = parseInt(timeIndexEl.max || "0", 10);
        if (cur >= max) { stopPlay(); return; }
        timeIndexEl.value = String(cur + 1);
        updateTimeLabels();
        scheduleRecalcOnScrub(false);
      }, interval);
    });
    pauseBtn.addEventListener("click", () => stopPlay());
    toStartBtn.addEventListener("click", () => { stopPlay(); timeIndexEl.value = "0"; updateTimeLabels(); scheduleRecalcOnScrub(true); });
    toEndBtn.addEventListener("click", () => { stopPlay(); timeIndexEl.value = String(timeIndexEl.max || "0"); updateTimeLabels(); scheduleRecalcOnScrub(true); });

    // ====== 範囲反映 ======
    applyRangeBtn.addEventListener("click", async () => {
      stopPlay();
      if (!applyRangeFromInputs()) return;
      const t = getSelectedTime();
      await buildSatellitesForTime(t);
      recalcDopHeatmap({ lite:false });
    });

    // ====== クリックで単点表示 ======
    map.on("click", (e) => {
      if (!allSatellites.length) {
        L.popup().setLatLng(e.latlng).setContent("TLEがありません。").openOn(map);
        return;
      }
      const elevMask = parseFloat(elevMaskEl.value) || 15;
      const obsHeightKm = parseFloat(obsHeightEl.value) || 0;
      const time = getSelectedTime();

      const { dops, visibleCount } = computeDopAtLocation(e.latlng.lat, e.latlng.lng, obsHeightKm, time, elevMask);
      if (dops.GDOP == null) {
        L.popup().setLatLng(e.latlng)
          .setContent(`緯度 ${e.latlng.lat.toFixed(2)}°, 経度 ${e.latlng.lng.toFixed(2)}°\n可視衛星: ${visibleCount}\nDOP: 計算不可(衛星不足)`)
          .openOn(map);
        return;
      }

      const gEff = applyTecToDop(dops.GDOP, e.latlng.lat, e.latlng.lng);
      const pEff = applyTecToDop(dops.PDOP, e.latlng.lat, e.latlng.lng);
      const hEff = applyTecToDop(dops.HDOP, e.latlng.lat, e.latlng.lng);
      const vEff = applyTecToDop(dops.VDOP, e.latlng.lat, e.latlng.lng);

      const html = `
        <b>${formatUtc(time)}</b><br/>
        緯度 ${e.latlng.lat.toFixed(2)}°, 経度 ${e.latlng.lng.toFixed(2)}°<br/>
        可視衛星: ${visibleCount}<br/>
        GDOP: ${gEff.toFixed(2)}<br/>
        PDOP: ${pEff.toFixed(2)}<br/>
        HDOP: ${hEff.toFixed(2)}<br/>
        VDOP: ${vEff.toFixed(2)}
      `;
      L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
    });

    // ====== 初期化 ======
    (async () => {
      clampRangeToNowPlusMinus3days();
      applyRangeFromInputs();

      // 初回：Browser cache を充実させたいならここ（任意）
      await refreshAndStoreTles();

      const t = getSelectedTime();
      await buildSatellitesForTime(t);
      recalcDopHeatmap({ lite:false });
    })();
  </script>
</body>
</html>
