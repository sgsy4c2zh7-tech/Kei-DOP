<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>GNSS DOP Heatmap – CelesTrak + satellite.js</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin: 0;
      letter-spacing: 0.03em;
    }
    h1 { font-size: 18px; }
    h2 { font-size: 15px; }
    h3 { font-size: 13px; }

    .page {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .toolbar {
      padding: 8px 12px;
      background: rgba(5, 8, 22, 0.96);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: grid;
      grid-template-columns: 2.7fr 2.7fr 2fr 2fr;
      grid-gap: 10px;
      align-items: center;
      z-index: 1000;
    }

    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      align-items: center;
    }

    .toolbar label {
      font-size: 11px;
      opacity: 0.85;
      white-space: nowrap;
    }

    .toolbar input[type="number"],
    .toolbar select {
      font-size: 11px;
      padding: 2px 4px;
      background: #0b1020;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      color: #f5f5f5;
    }

    .toolbar input[type="color"] {
      width: 24px;
      height: 18px;
      padding: 0;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: transparent;
    }

    .toolbar input[type="range"] {
      width: 120px;
    }

    .toolbar button {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #3b82f6, #22c55e);
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    .toolbar button:hover {
      opacity: 0.9;
    }

    .map-container {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    #map {
      position: absolute;
      inset: 0;
      z-index: 200;
    }

    /* Leaflet canvas上にかぶせるヒートマップ用レイヤ（Rect） */
    .leaflet-overlay-pane svg .dop-cell {
      stroke-width: 0;
    }

    .status-bar {
      position: absolute;
      left: 10px;
      bottom: 8px;
      z-index: 900;
      padding: 6px 10px;
      background: rgba(5, 8, 22, 0.85);
      border-radius: 999px;
      font-size: 11px;
      display: flex;
      gap: 10px;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.12);
    }

    .status-bar span.label {
      opacity: 0.75;
    }

    .status-bar span.value {
      font-variant-numeric: tabular-nums;
    }

    #statusText {
      position: absolute;
      right: 10px;
      bottom: 8px;
      z-index: 900;
      padding: 6px 10px;
      background: rgba(127, 29, 29, 0.9);
      color: #fecaca;
      font-size: 11px;
      border-radius: 8px;
      max-width: 360px;
      display: none;
    }

    .colorbar-preview {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
      margin-top: 2px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .checkbox-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 11px;
    }
    .checkbox-row label span {
      margin-left: 2px;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="toolbar">
      <!-- GNSS & DOP -->
      <div class="toolbar-group">
        <div class="checkbox-row">
          <label><input type="checkbox" class="sys-check" value="gps" checked><span>GPS</span></label>
          <label><input type="checkbox" class="sys-check" value="galileo" checked><span>Galileo</span></label>
          <label><input type="checkbox" class="sys-check" value="glonass" checked><span>GLONASS</span></label>
          <label><input type="checkbox" class="sys-check" value="beidou" checked><span>BeiDou</span></label>
          <label><input type="checkbox" class="sys-check" value="qzss" checked><span>QZSS</span></label>
        </div>
        <label>
          DOP:
          <select id="dopType">
            <option value="GDOP">GDOP</option>
            <option value="PDOP">PDOP</option>
            <option value="HDOP">HDOP</option>
            <option value="VDOP">VDOP</option>
          </select>
        </label>
        <label>
          仰角マスク(°):
          <input id="elevMask" type="number" value="15" min="0" max="45" step="1" />
        </label>
        <label>
          基準高度(km):
          <input id="obsHeightKm" type="number" value="0" step="0.1" />
        </label>
      </div>

      <!-- 時間オフセット & フォーカス -->
      <div class="toolbar-group">
        <label>
          時間オフセット(h, -120〜+120):
          <input id="timeOffsetHours" type="range" min="-120" max="120" step="1" value="0" />
        </label>
        <span id="timeOffsetLabel" style="font-size:11px;min-width:72px;">Δt = 0 h</span>
        <span id="utcTimeLabel" style="font-size:11px;white-space:nowrap;">UTC: -</span>
        <button id="resetTime">Δt=0</button>
        <label>
          フォーカス:
          <select id="focusRegion">
            <option value="world">World</option>
            <option value="japan">Japan</option>
            <option value="us">USA</option>
            <option value="europe">Europe</option>
            <option value="australia">Australia</option>
            <option value="southamerica">South America</option>
            <option value="africa">Africa</option>
          </select>
        </label>
      </div>

      <!-- カラーバー & 透明度 -->
      <div class="toolbar-group">
        <label>
          DOP min:
          <input id="dopMin" type="number" value="0.5" step="0.1" />
        </label>
        <label>
          DOP max:
          <input id="dopMax" type="number" value="10" step="0.5" />
        </label>
        <label>
          色(低):
          <input id="colorLow" type="color" value="#22c55e" />
        </label>
        <label>
          色(中):
          <input id="colorMid" type="color" value="#eab308" />
        </label>
        <label>
          色(高):
          <input id="colorHigh" type="color" value="#ef4444" />
        </label>
        <div class="colorbar-preview" id="colorbarPreview"></div>
      </div>

      <!-- 透明度 & 実行 -->
      <div class="toolbar-group">
        <label>
          ヒートマップ透明度:
          <input id="alphaSlider" type="range" min="0.1" max="1" step="0.05" value="0.7" />
        </label>
        <span id="alphaLabel" style="font-size:11px;">α = 0.70</span>
        <button id="reloadTle">TLE更新</button>
        <button id="recalcBtn">再計算</button>
      </div>
    </div>

    <div class="map-container">
      <div id="map"></div>
      <div class="status-bar">
        <span class="label">エポック:</span>
        <span class="value" id="epochLabel">読み込み中...</span>
        <span class="label">可視衛星数(東京):</span>
        <span class="value" id="visibleTokyoLabel">–</span>
        <span class="label">DOP(東京):</span>
        <span class="value" id="dopTokyoLabel">–</span>
      </div>
      <div id="statusText"></div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin="">
  </script>

  <!-- satellite.js (SGP4) -->
  <script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>

  <script>
    // ====== 設定 ======
    const systemsConfig = {
      gps:     { label: "GPS",     group: "gps-ops" },
      galileo: { label: "Galileo", group: "galileo" },
      glonass: { label: "GLONASS", group: "glonass" },
      beidou:  { label: "BeiDou",  group: "beidou" },
      qzss:    { label: "QZSS",    group: "qzss" }
    };

    // グリッド解像度（°）
    const LAT_STEP = 10;
    const LON_STEP = 10;

    // ====== 状態変数 ======
    let allSatellites = []; // {name, system, satrec}
    let lastTleEpochText = "–";
    let dopLayer = null;
    let currentAlpha = 0.7;

    // タイムスライダー基準時刻（ページ読み込み時の UTC）
    const baseTime = new Date();  // ブラウザの「今」

    // ====== UI 要素 ======
    const dopTypeSel   = document.getElementById("dopType");
    const elevMaskEl   = document.getElementById("elevMask");
    const obsHeightEl  = document.getElementById("obsHeightKm");
    const timeOffsetEl = document.getElementById("timeOffsetHours");
    const timeOffsetLabel = document.getElementById("timeOffsetLabel");
    const utcTimeLabel = document.getElementById("utcTimeLabel");
    const focusRegionEl   = document.getElementById("focusRegion");
    const dopMinEl    = document.getElementById("dopMin");
    const dopMaxEl    = document.getElementById("dopMax");
    const colorLowEl  = document.getElementById("colorLow");
    const colorMidEl  = document.getElementById("colorMid");
    const colorHighEl = document.getElementById("colorHigh");
    const colorbarPreview = document.getElementById("colorbarPreview");
    const alphaSlider = document.getElementById("alphaSlider");
    const alphaLabel  = document.getElementById("alphaLabel");
    const reloadTleBtn= document.getElementById("reloadTle");
    const recalcBtn   = document.getElementById("recalcBtn");
    const epochLabel  = document.getElementById("epochLabel");
    const visibleTokyoLabel = document.getElementById("visibleTokyoLabel");
    const dopTokyoLabel     = document.getElementById("dopTokyoLabel");
    const statusText  = document.getElementById("statusText");
    const sysChecks   = document.querySelectorAll(".sys-check");

    // ====== Leaflet map 初期化 ======
    const map = L.map("map", {
      worldCopyJump: true,
      center: [35, 140], // 日本付近
      zoom: 3
    });

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 8,
      minZoom: 2,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    // DOP 表示用レイヤ
    dopLayer = L.layerGroup().addTo(map);

    // ====== ヘルパー: メッセージ ======
    function setStatus(msg, isError = false) {
      if (!msg) {
        statusText.style.display = "none";
        statusText.textContent = "";
        return;
      }
      statusText.style.display = "block";
      statusText.textContent = msg;
      statusText.style.background = isError ? "rgba(127,29,29,0.9)" : "rgba(15,23,42,0.9)";
      statusText.style.color = isError ? "#fecaca" : "#e5e7eb";
    }

    // ====== ヘルパー: カラー関連 ======
    function hexToRgb(hex) {
      const m = hex.replace("#", "");
      const bigint = parseInt(m, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }

    function interpColor(c1, c2, t) {
      return {
        r: Math.round(c1.r + (c2.r - c1.r) * t),
        g: Math.round(c1.g + (c2.g - c1.g) * t),
        b: Math.round(c1.b + (c2.b - c1.b) * t)
      };
    }

    function colorForDop(value, minV, maxV, lowHex, midHex, highHex) {
      if (value == null || isNaN(value)) return "rgba(0,0,0,0)";
      if (value <= minV) value = minV;
      if (value >= maxV) value = maxV;
      const t = (value - minV) / (maxV - minV + 1e-9);
      const low = hexToRgb(lowHex);
      const mid = hexToRgb(midHex);
      const high = hexToRgb(highHex);

      let c;
      if (t < 0.5) {
        c = interpColor(low, mid, t * 2);
      } else {
        c = interpColor(mid, high, (t - 0.5) * 2);
      }
      return `rgba(${c.r},${c.g},${c.b},${currentAlpha})`;
    }

    function updateColorbarPreview() {
      const low = colorLowEl.value;
      const mid = colorMidEl.value;
      const high = colorHighEl.value;
      colorbarPreview.style.background = `linear-gradient(90deg, ${low}, ${mid}, ${high})`;
    }

    updateColorbarPreview();

    colorLowEl.addEventListener("input", updateColorbarPreview);
    colorMidEl.addEventListener("input", updateColorbarPreview);
    colorHighEl.addEventListener("input", updateColorbarPreview);

    // ====== 時刻表示関連 ======
    function formatUtc(dt) {
      const y  = dt.getUTCFullYear();
      const mo = String(dt.getUTCMonth() + 1).padStart(2, "0");
      const d  = String(dt.getUTCDate()).padStart(2, "0");
      const h  = String(dt.getUTCHours()).padStart(2, "0");
      const m  = String(dt.getUTCMinutes()).padStart(2, "0");
      return `${y}-${mo}-${d} ${h}:${m} UTC`;
    }

    function updateTimeOffsetLabelAndUtc() {
      const v = parseInt(timeOffsetEl.value, 10) || 0;
      timeOffsetLabel.textContent = `Δt = ${v} h`;
      const t = new Date(baseTime.getTime() + v * 3600 * 1000);
      utcTimeLabel.textContent = `UTC: ${formatUtc(t)}`;
    }

    updateTimeOffsetLabelAndUtc();

    timeOffsetEl.addEventListener("input", () => {
      updateTimeOffsetLabelAndUtc();
      recalcDopHeatmap();   // スライダー操作とともにヒートマップも推移
    });

    document.getElementById("resetTime").addEventListener("click", () => {
      timeOffsetEl.value = 0;
      updateTimeOffsetLabelAndUtc();
      recalcDopHeatmap();
    });

    // ====== 透明度 ======
    function updateAlpha() {
      currentAlpha = parseFloat(alphaSlider.value);
      alphaLabel.textContent = `α = ${currentAlpha.toFixed(2)}`;
      // 既存レイヤの fillOpacity を更新
      dopLayer.eachLayer(layer => {
        if (layer.setStyle) {
          layer.setStyle({ fillOpacity: currentAlpha });
        }
      });
    }
    updateAlpha();
    alphaSlider.addEventListener("input", () => {
      updateAlpha();
    });

    // ====== フォーカス ======
    focusRegionEl.addEventListener("change", () => {
      const v = focusRegionEl.value;
      switch (v) {
        case "world":
          map.setView([20, 0], 2);
          break;
        case "japan":
          map.setView([36, 138], 5);
          break;
        case "us":
          map.setView([39, -100], 4);
          break;
        case "europe":
          map.setView([50, 10], 4);
          break;
        case "australia":
          map.setView([-25, 135], 4);
          break;
        case "southamerica":
          map.setView([-15, -60], 4);
          break;
        case "africa":
          map.setView([0, 20], 4);
          break;
      }
    });

    // ====== TLE ロード ======
    async function fetchTleGroup(groupName) {
      const url = `https://celestrak.org/NORAD/elements/gp.php?GROUP=${encodeURIComponent(groupName)}&FORMAT=tle`;
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`TLE取得失敗: ${groupName} (${res.status})`);
      }
      const text = await res.text();
      return text;
    }

    // 2行TLE対応 parseTleText
    function parseTleText(tleText, systemKey) {
      const lines = tleText
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length > 0);

      const sats = [];
      let tmpName = null;
      let satIndex = 0;

      for (let i = 0; i < lines.length; ) {
        const line = lines[i];

        // 「0 Name」や名前だけの行の場合：名前として保持
        if (!line.startsWith("1 ") && !line.startsWith("2 ")) {
          tmpName = line;
          i++;
          continue;
        }

        // "1 " で始まり、次が "2 " なら 2行TLE と判断
        if (line.startsWith("1 ") && (i + 1) < lines.length && lines[i + 1].startsWith("2 ")) {
          const l1 = lines[i];
          const l2 = lines[i + 1];

          const name = tmpName || `${systemKey.toUpperCase()}-${++satIndex}`;

          try {
            const satrec = satellite.twoline2satrec(l1, l2);
            sats.push({ name, system: systemKey, satrec });
          } catch (e) {
            console.warn("TLE parse error", name, e);
          }

          tmpName = null;
          i += 2;
          continue;
        }

        // それ以外の行はスキップ
        i++;
      }

      return sats;
    }

    async function loadSelectedTles() {
      setStatus("TLE取得中 (CelesTrak)...", false);
      allSatellites = [];
      let epochTexts = [];

      const selectedSystems = [];
      sysChecks.forEach(ch => {
        if (ch.checked) selectedSystems.push(ch.value);
      });

      if (selectedSystems.length === 0) {
        setStatus("少なくとも1つのGNSSシステムを選択してください。", true);
        return;
      }

      try {
        for (const key of selectedSystems) {
          const cfg = systemsConfig[key];
          if (!cfg) continue;
          const text = await fetchTleGroup(cfg.group);
          const sats = parseTleText(text, key);
          allSatellites.push(...sats);

          // 代表TLEからエポック文字列を拾う（ざっくり表示用）
          const line1 = text.split(/\r?\n/).find(l => l.startsWith("1 "));
          if (line1) {
            epochTexts.push(line1.substring(18, 32).trim());
          }
        }
        if (allSatellites.length === 0) {
          setStatus("TLEがパースできませんでした。", true);
          return;
        }
        lastTleEpochText = epochTexts.join(", ");
        epochLabel.textContent = lastTleEpochText || "–";
        setStatus("TLE取得完了。再計算ボタンやタイムスライダーでDOPを更新できます。", false);
      } catch (err) {
        console.error(err);
        setStatus("TLE取得時にエラーが発生しました: " + err.message, true);
      }
    }

    reloadTleBtn.addEventListener("click", () => {
      loadSelectedTles().then(() => {
        recalcDopHeatmap();
      });
    });

    // ====== DOP 計算 ======
    // G: n×4 行列 (東, 北, 上, クロック)
    function computeDopsFromMatrix(G) {
      const n = G.length;
      if (n < 4) {
        return { GDOP: null, PDOP: null, HDOP: null, VDOP: null };
      }
      const GTG = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]
      ];

      for (let i = 0; i < n; i++) {
        const row = G[i];
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            GTG[r][c] += row[r] * row[c];
          }
        }
      }

      // 4x4 逆行列
      const Q = invert4(GTG);
      if (!Q) {
        return { GDOP: null, PDOP: null, HDOP: null, VDOP: null };
      }

      const qxx = Q[0][0];
      const qyy = Q[1][1];
      const qzz = Q[2][2];
      const qtt = Q[3][3];

      const GDOP = Math.sqrt(Math.max(qxx + qyy + qzz + qtt, 0));
      const PDOP = Math.sqrt(Math.max(qxx + qyy + qzz, 0));
      const HDOP = Math.sqrt(Math.max(qxx + qyy, 0));
      const VDOP = Math.sqrt(Math.max(qzz, 0));

      return { GDOP, PDOP, HDOP, VDOP };
    }

    function invert4(M) {
      const A = [
        [...M[0], 1,0,0,0],
        [...M[1], 0,1,0,0],
        [...M[2], 0,0,1,0],
        [...M[3], 0,0,0,1]
      ];

      const N = 4;
      for (let i = 0; i < N; i++) {
        // ピボット選択
        let maxRow = i;
        let maxVal = Math.abs(A[i][i]);
        for (let r = i+1; r < N; r++) {
          const v = Math.abs(A[r][i]);
          if (v > maxVal) {
            maxVal = v; maxRow = r;
          }
        }
        if (maxVal < 1e-12) return null;
        if (maxRow !== i) {
          const tmp = A[i];
          A[i] = A[maxRow];
          A[maxRow] = tmp;
        }

        // 正規化
        const pivot = A[i][i];
        for (let c = 0; c < 8; c++) A[i][c] /= pivot;

        // 他行消去
        for (let r = 0; r < N; r++) {
          if (r === i) continue;
          const factor = A[r][i];
          for (let c = 0; c < 8; c++) {
            A[r][c] -= factor * A[i][c];
          }
        }
      }

      const inv = [
        [A[0][4],A[0][5],A[0][6],A[0][7]],
        [A[1][4],A[1][5],A[1][6],A[1][7]],
        [A[2][4],A[2][5],A[2][6],A[2][7]],
        [A[3][4],A[3][5],A[3][6],A[3][7]]
      ];
      return inv;
    }

    // 与えられた地点(lat, lon, heightKm)と日時timeで可視衛星からDOPを計算
    function computeDopAtLocation(latDeg, lonDeg, heightKm, time, elevMaskDeg) {
      if (!allSatellites || allSatellites.length === 0) {
        return { dops: {GDOP:null,PDOP:null,HDOP:null,VDOP:null}, visibleCount: 0 };
      }

      const gmst = satellite.gstime(time);
      const observerGd = {
        latitude:  satellite.degreesToRadians(latDeg),
        longitude: satellite.degreesToRadians(lonDeg),
        height:    heightKm
      };

      const G = [];
      let visibleCount = 0;

      for (const sat of allSatellites) {
        const prop = satellite.propagate(sat.satrec, time);
        if (!prop.position) continue; // propagate失敗
        const positionEci = prop.position;
        const positionEcf = satellite.eciToEcf(positionEci, gmst);
        const look = satellite.ecfToLookAngles(observerGd, positionEcf);
        const elevDeg = satellite.radiansToDegrees(look.elevation);
        if (elevDeg < elevMaskDeg) continue;

        visibleCount++;

        const az = look.azimuth;
        const el = look.elevation;
        const cosEl = Math.cos(el);
        const sinEl = Math.sin(el);

        // ENU 系: [E, N, U, クロック]
        const eComp = cosEl * Math.sin(az);
        const nComp = cosEl * Math.cos(az);
        const uComp = sinEl;

        G.push([eComp, nComp, uComp, 1.0]);
      }

      const dops = computeDopsFromMatrix(G);
      return { dops, visibleCount };
    }

    // ====== グリッドDOP計算 & Leaflet表示 ======
    function recalcDopHeatmap() {
      if (!allSatellites || allSatellites.length === 0) {
        setStatus("まず「TLE更新」で衛星を読み込んでください。", true);
        return;
      }

      const dopType = dopTypeSel.value;
      const elevMask = parseFloat(elevMaskEl.value) || 15;
      const obsHeightKm = parseFloat(obsHeightEl.value) || 0;

      const dopMin = parseFloat(dopMinEl.value) || 0.5;
      const dopMax = parseFloat(dopMaxEl.value) || 10;
      const lowC  = colorLowEl.value;
      const midC  = colorMidEl.value;
      const highC = colorHighEl.value;

      const dtHours = parseInt(timeOffsetEl.value, 10) || 0;
      const time = new Date(baseTime.getTime() + dtHours * 3600 * 1000);

      setStatus("DOP計算中...", false);

      // 既存レイヤ削除
      dopLayer.clearLayers();

      // 東京のDOPを別途計算してステータス表示
      const tokyoRes = computeDopAtLocation(35.68, 139.76, obsHeightKm, time, elevMask);
      const tokDops  = tokyoRes.dops;
      visibleTokyoLabel.textContent = tokyoRes.visibleCount.toString();
      if (tokDops.GDOP == null) {
        dopTokyoLabel.textContent = "–";
      } else {
        const txt = [
          `G:${tokDops.GDOP.toFixed(1)}`,
          `P:${tokDops.PDOP.toFixed(1)}`,
          `H:${tokDops.HDOP.toFixed(1)}`,
          `V:${tokDops.VDOP.toFixed(1)}`
        ].join(" ");
        dopTokyoLabel.textContent = txt;
      }

      // グリッドループ
      for (let lat = -80; lat <= 80; lat += LAT_STEP) {
        for (let lon = -180; lon < 180; lon += LON_STEP) {
          const centerLat = lat + LAT_STEP / 2;
          const centerLon = lon + LON_STEP / 2;

          const { dops } = computeDopAtLocation(centerLat, centerLon, obsHeightKm, time, elevMask);
          const val = dops[dopType] || null;
          if (val == null || !isFinite(val)) continue;

          const color = colorForDop(val, dopMin, dopMax, lowC, midC, highC);

          const bounds = [
            [lat, lon],
            [lat + LAT_STEP, lon + LON_STEP]
          ];

          const rect = L.rectangle(bounds, {
            stroke: false,
            fillColor: color,
            fillOpacity: currentAlpha,
            interactive: false,
            className: "dop-cell"
          });
          dopLayer.addLayer(rect);
        }
      }

      setStatus(`DOP計算完了 (Δt=${dtHours}h, 仰角≥${elevMask.toFixed(0)}°)。`, false);
    }

    recalcBtn.addEventListener("click", () => {
      recalcDopHeatmap();
    });

    // ====== 地図クリックでその地点のDOP表示 ======
    map.on("click", (e) => {
      if (!allSatellites || allSatellites.length === 0) {
        L.popup()
          .setLatLng(e.latlng)
          .setContent("まず TLE を読み込んでください。")
          .openOn(map);
        return;
      }
      const elevMask = parseFloat(elevMaskEl.value) || 15;
      const obsHeightKm = parseFloat(obsHeightEl.value) || 0;
      const dtHours = parseInt(timeOffsetEl.value, 10) || 0;
      const time = new Date(baseTime.getTime() + dtHours * 3600 * 1000);

      const { dops, visibleCount } = computeDopAtLocation(
        e.latlng.lat,
        e.latlng.lng,
        obsHeightKm,
        time,
        elevMask
      );
      if (dops.GDOP == null) {
        L.popup()
          .setLatLng(e.latlng)
          .setContent(`緯度 ${e.latlng.lat.toFixed(2)}°, 経度 ${e.latlng.lng.toFixed(2)}°<br/>可視衛星: ${visibleCount}<br/>DOP: 計算不可(衛星不足)`)
          .openOn(map);
        return;
      }

      const html = `
        緯度 ${e.latlng.lat.toFixed(2)}°, 経度 ${e.latlng.lng.toFixed(2)}°<br/>
        可視衛星: ${visibleCount}<br/>
        GDOP: ${dops.GDOP.toFixed(2)}<br/>
        PDOP: ${dops.PDOP.toFixed(2)}<br/>
        HDOP: ${dops.HDOP.toFixed(2)}<br/>
        VDOP: ${dops.VDOP.toFixed(2)}
      `;
      L.popup()
        .setLatLng(e.latlng)
        .setContent(html)
        .openOn(map);
    });

    // ====== 初期ロード ======
    (async () => {
      setStatus("初期TLEを取得しています (CelesTrak GNSS)...", false);
      await loadSelectedTles();
      recalcDopHeatmap();
    })();
  </script>
</body>
</html>
